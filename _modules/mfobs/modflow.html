

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mfobs.modflow &mdash; modflow-obs 0.post8+g07d6cf1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> modflow-obs
          

          
          </a>

          
            
            
              <div class="version">
                0.post8+g07d6cf1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../philosophy.html">Philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Example.html">Examples</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Example.html"> Demo of Modflow-obs</a></li>
</ul>
<p class="caption"><span class="caption-text">Code reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html"> Modules</a></li>
</ul>
<p class="caption"><span class="caption-text">Release history</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../release-history.html"> Release History</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing to modflow-obs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">modflow-obs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>mfobs.modflow</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mfobs.modflow</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions specific to MODFLOW and flopy</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">affine</span> <span class="kn">import</span> <span class="n">Affine</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">flopy</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">flopy</span> <span class="o">=</span> <span class="kc">False</span>
<span class="kn">from</span> <span class="nn">mfobs.fileio</span> <span class="kn">import</span> <span class="n">write_insfile</span>


<div class="viewcode-block" id="get_gwf_obs_input"><a class="viewcode-back" href="../../api/mfobs.modflow.html#mfobs.modflow.get_gwf_obs_input">[docs]</a><span class="k">def</span> <span class="nf">get_gwf_obs_input</span><span class="p">(</span><span class="n">gwf_obs_input_file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read the first BEGIN continuous  FILEOUT block of an input</span>
<span class="sd">    file to the MODFLOW-6 GWF observation utility.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gwf_obs_input_file : str</span>
<span class="sd">        Input file to MODFLOW-6 observation utility (contains layer information).</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    As-is, this only reads the first block. Modflow-setup writes all of the</span>
<span class="sd">    observation input to a single block, but observation input can</span>
<span class="sd">    be broken out into multiple blocks (one per file).</span>

<span class="sd">    This also doesn&#39;t work with open/close statements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">gwf_obs_input_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;BEGIN continuous&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">delim_whitespace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">error_bad_lines</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;obsname&#39;</span><span class="p">,</span> <span class="s1">&#39;obstype&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">]</span>
    <span class="c1"># cast columns as ints and convert to zero-based</span>
    <span class="k">for</span> <span class="n">index_col</span> <span class="ow">in</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">index_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">index_col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="get_ij"><a class="viewcode-back" href="../../api/mfobs.modflow.html#mfobs.modflow.get_ij">[docs]</a><span class="k">def</span> <span class="nf">get_ij</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the row and column of a point or sequence of points</span>
<span class="sd">    in real-world coordinates. Uses the affine package. Basically,</span>

<span class="sd">    * to get an x, y: transform * (col, row)</span>
<span class="sd">    * the inverse, ~transform * (x, y) returns a fractional i, j location on the grid</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    transform : affine.Affine instance</span>
<span class="sd">        An `affine.Affine &lt;https://github.com/sgillies/affine&gt;`_ object describing the orientation</span>
<span class="sd">        of the model grid. Modflow-setup :class:`~mfsetup.grid.MFsetupGrid` have this attached</span>
<span class="sd">        via the :meth:`~mfsetup.grid.MFsetupGrid.transform` property. Example::</span>

<span class="sd">            modelgrid_transform=affine.Affine(1000.0, 0.0, 500955,</span>
<span class="sd">                                              0.0, -1000.0, 1205285)</span>

<span class="sd">        for a uniform spacing of 1000 and upper left corner of 500955, 1205285</span>
<span class="sd">        with a rotation of 45 degrees, counter-clockwise about the upper left corner::</span>

<span class="sd">            modelgrid_transform=affine.Affine(1000.0, 0.0, 500955,</span>
<span class="sd">                                              0.0, -1000.0, 1205285).rotation(45.)</span>

<span class="sd">        An ``affine.Affine`` instance can also be created from a</span>
<span class="sd">        `Modflow-setup &lt;https://github.com/aleaf/modflow-setup&gt;`_</span>
<span class="sd">        grid JSON file via the :func:`~mfobs.modflow.get_modelgrid_transform` function.</span>

<span class="sd">    x : scalar or sequence of x coordinates</span>
<span class="sd">    y : scalar or sequence of y coordinates</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    i : row or sequence of rows (zero-based)</span>
<span class="sd">    j : column or sequence of columns (zero-based)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="o">~</span><span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span></div>


<div class="viewcode-block" id="get_kstp_kper"><a class="viewcode-back" href="../../api/mfobs.modflow.html#mfobs.modflow.get_kstp_kper">[docs]</a><span class="k">def</span> <span class="nf">get_kstp_kper</span><span class="p">(</span><span class="n">nstp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a sequence of the number of timesteps in each stress period,</span>
<span class="sd">    return a sequence of timestep, period tuples (kstp, kper) used</span>
<span class="sd">    by various flopy methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kstp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kper</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nstp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nstp</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstp</span><span class="p">):</span>
            <span class="n">kstp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">kper</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kstp</span><span class="p">,</span> <span class="n">kper</span></div>


<div class="viewcode-block" id="get_layer"><a class="viewcode-back" href="../../api/mfobs.modflow.html#mfobs.modflow.get_layer">[docs]</a><span class="k">def</span> <span class="nf">get_layer</span><span class="p">(</span><span class="n">column_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pandas appends duplicate column names with a .*,</span>
<span class="sd">    where * is the number of duplicate names from left to right</span>
<span class="sd">    (e.g. obs, obs.1, obs.2, ...). Modflow-setup writes observation input</span>
<span class="sd">    for each model layer, at each site location, with the same observation prefix (site identifier).</span>
<span class="sd">    MODFLOW-6 reports the result for each layer with duplicate column names,</span>
<span class="sd">    with layers increasing from left to right (e.g. obs, obs, obs, ...).</span>

<span class="sd">    Parse the layer number from column_name, returning zero if there is no &#39;.&#39; separator.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The approach can&#39;t be used if the model includes inactive cells (including pinched layers)</span>
<span class="sd">    at the locations of observations, because it assumes that the layer numbers are consecutive,</span>
<span class="sd">    starting at 0. For example, a pinched layer 2 in a 4 layer model would result in the observation</span>
<span class="sd">    being in layers 0, 1, 3, which would be misinterpreted as 0, 1, 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">column_name</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">column_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="get_mf6_single_variable_obs"><a class="viewcode-back" href="../../api/mfobs.modflow.html#mfobs.modflow.get_mf6_single_variable_obs">[docs]</a><span class="k">def</span> <span class="nf">get_mf6_single_variable_obs</span><span class="p">(</span><span class="n">perioddata</span><span class="p">,</span>
                                <span class="n">model_output_file</span><span class="p">,</span>
                                <span class="n">gwf_obs_input_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">variable_name</span><span class="o">=</span><span class="s1">&#39;values&#39;</span><span class="p">,</span>
                                <span class="n">obsnme_date_suffix_format</span><span class="o">=</span><span class="s1">&#39;%Y%m&#39;</span><span class="p">,</span>
                                <span class="n">label_period_as_steady_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="nb">abs</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read raw MODFLOW-6 observation output from csv table with</span>
<span class="sd">    times along the row axis and observations along the column axis. Reshape</span>
<span class="sd">    (stack) results to be n times x n sites rows, with a single observation value</span>
<span class="sd">    in each row. If there is more than one time in a stress period, retain only</span>
<span class="sd">    the last time (so that there is one observation per stress period for each site.</span>
<span class="sd">    If an input file to the MODFLOW-6 observation utility is included,</span>
<span class="sd">    include the observation layer number in the output.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    perioddata : str</span>
<span class="sd">        Path to csv file with start/end dates for stress periods. Must have columns</span>
<span class="sd">        &#39;time&#39; (modflow time, in days), &#39;start_datetime&#39; (start date for the stress period)</span>
<span class="sd">        and &#39;end_datetime&#39; (end date for the stress period).</span>
<span class="sd">    model_output_file : str</span>
<span class="sd">        Path to MODFLOW-6 observation csv output (shape: n times rows x n obs columns).</span>
<span class="sd">    gwf_obs_input_file : str</span>
<span class="sd">        Input file to MODFLOW-6 observation utility (contains layer information).</span>
<span class="sd">    variable_name : str, optional</span>
<span class="sd">        Column with simulated output will be named &quot;sim_&lt;variable_name&quot;,</span>
<span class="sd">        by default &#39;head&#39;</span>
<span class="sd">    obsnme_date_suffix_format : str, optional</span>
<span class="sd">        Format for date suffix of obsnmes. By default, &#39;%Y%m&#39;,</span>
<span class="sd">        which would yield &#39;202001&#39; for a Jan, 2020 observation.</span>
<span class="sd">        Observation names are created following the format of</span>
<span class="sd">        &lt;obsprefix&gt;_&lt;date suffix&gt;</span>
<span class="sd">    label_period_as_steady_state : int, optional</span>
<span class="sd">        Zero-based model stress period where observations will be</span>
<span class="sd">        assigned the suffix &#39;ss&#39; instead of a date suffix.</span>
<span class="sd">        By default, None, in which case all model output is assigned</span>
<span class="sd">        a date suffix based on the start date of the stress period.</span>
<span class="sd">    abs : bool, optional</span>
<span class="sd">        Option to convert simulated values to absolute values</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    results : DataFrame</span>
<span class="sd">        DataFrame with one head observation per row, with the following columns:</span>

<span class="sd">        =================== =============================================================</span>
<span class="sd">        per                 zero-based model stress period</span>
<span class="sd">        obsprefix           prefix of observation name (site identifier)</span>
<span class="sd">        sim_&lt;variable_name&gt; column with simulated values</span>
<span class="sd">        datetime            pandas datetimes, based on stress period start date</span>
<span class="sd">        layer               zero-based model layer</span>
<span class="sd">        obsnme              observation name based on format of &lt;obsprefix&gt;_&#39;%Y%m&#39;</span>

<span class="sd">        =================== =============================================================</span>

<span class="sd">        Example observation names:</span>

<span class="sd">        site1000_202001, for a Jan. 2020 observation at site1000</span>

<span class="sd">        steady-state stress periods are given the suffix of &#39;ss&#39;</span>
<span class="sd">        e.g. site1000_ss</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">perioddata</span> <span class="o">=</span> <span class="n">perioddata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;reading model output from </span><span class="si">{}</span><span class="s1">...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model_output_file</span><span class="p">))</span>
    <span class="n">model_output</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">model_output_file</span><span class="p">)</span>

    <span class="c1"># convert all observation names to lower case</span>
    <span class="n">model_output</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">model_output</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="c1"># add stress period information to model output</span>
    <span class="c1"># by having pandas match time floats in indices</span>
    <span class="c1"># the last time in each stress period is retained</span>
    <span class="c1"># (corresponding to the model end time listed in perioddata)</span>
    <span class="n">model_output</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">model_output</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
    <span class="n">perioddata</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">perioddata</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
    <span class="n">model_output</span><span class="p">[</span><span class="s1">&#39;per&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perioddata</span><span class="p">[</span><span class="s1">&#39;per&#39;</span><span class="p">]</span>
    <span class="n">model_output</span><span class="p">[</span><span class="s1">&#39;perioddata_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perioddata</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
    <span class="n">model_output</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;per&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">model_output</span><span class="p">[</span><span class="s1">&#39;per&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_output</span><span class="p">[</span><span class="s1">&#39;per&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">model_output</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">model_output</span><span class="o">.</span><span class="n">perioddata_time</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">model_output</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">model_output</span><span class="p">[</span><span class="s1">&#39;per&#39;</span><span class="p">]</span>

    <span class="c1"># reshape the model output from (nper rows, nsites columns) to nper x nsites rows</span>
    <span class="n">stacked</span> <span class="o">=</span> <span class="n">model_output</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;perioddata_time&#39;</span><span class="p">,</span> <span class="s1">&#39;per&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">simval_col</span> <span class="o">=</span> <span class="s1">&#39;sim_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">variable_name</span><span class="p">)</span>
    <span class="n">stacked</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;per&#39;</span><span class="p">,</span> <span class="s1">&#39;obsprefix&#39;</span><span class="p">,</span> <span class="n">simval_col</span><span class="p">]</span>

    <span class="c1"># optionally convert simulated values to absolute values</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">:</span>
        <span class="n">stacked</span><span class="p">[</span><span class="n">simval_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">stacked</span><span class="p">[</span><span class="n">simval_col</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>

    <span class="c1"># add dates</span>
    <span class="n">period_start_dates</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">perioddata</span><span class="o">.</span><span class="n">per</span><span class="p">,</span> <span class="n">perioddata</span><span class="o">.</span><span class="n">start_datetime</span><span class="p">))</span>
    <span class="n">stacked</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="n">period_start_dates</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">per</span><span class="p">)</span> <span class="k">for</span> <span class="n">per</span> <span class="ow">in</span> <span class="n">stacked</span><span class="o">.</span><span class="n">per</span><span class="p">])</span>

    <span class="c1"># parse the layers from the column positions (prior to stacking)</span>
    <span class="k">if</span> <span class="n">gwf_obs_input_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gwf_obs_input</span> <span class="o">=</span> <span class="n">get_gwf_obs_input</span><span class="p">(</span><span class="n">gwf_obs_input_file</span><span class="p">)</span>
        <span class="c1"># Assign layer to each observation,</span>
        <span class="c1"># assuming that numbering in gwf_obs_input is repeated nper times</span>
        <span class="n">nper</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stacked</span><span class="o">.</span><span class="n">per</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="n">stacked</span><span class="p">[</span><span class="s1">&#39;layer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gwf_obs_input</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">*</span> <span class="n">nper</span>

    <span class="c1"># reset the obsprefixes to be the same for different layers at a location</span>
    <span class="n">stacked</span><span class="p">[</span><span class="s1">&#39;obsprefix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">prefix</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">stacked</span><span class="o">.</span><span class="n">obsprefix</span><span class="p">]</span>

    <span class="c1"># assign obsnames using the prefixes (location identifiers) and month</span>
    <span class="n">obsnames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="n">dt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stacked</span><span class="o">.</span><span class="n">obsprefix</span><span class="p">,</span> <span class="n">stacked</span><span class="o">.</span><span class="n">per</span><span class="p">,</span> <span class="n">stacked</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">per</span> <span class="o">==</span> <span class="n">label_period_as_steady_state</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_ss&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">obsnme_date_suffix_format</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="n">obsnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">stacked</span><span class="p">[</span><span class="s1">&#39;obsnme&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obsnames</span>

    <span class="c1"># drop any duplicate observations, keeping those from transient periods</span>
    <span class="c1"># (for example, an initial steady-state period that isn&#39;t being used for observations</span>
    <span class="c1"># and a subsequent transient period with the same start date)</span>
    <span class="c1"># first make temp obsnames that include layer</span>
    <span class="c1"># steady state periods that are being used for observations (label_period_as_steady_state=True)</span>
    <span class="c1"># won&#39;t be dropped because their obs will have an &quot;ss&quot; suffix instead of a date suffix</span>
    <span class="k">if</span> <span class="n">gwf_obs_input_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">unique_obsnames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">layer</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stacked</span><span class="o">.</span><span class="n">obsnme</span><span class="p">,</span> <span class="n">stacked</span><span class="o">.</span><span class="n">layer</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unique_obsnames</span> <span class="o">=</span> <span class="n">stacked</span><span class="o">.</span><span class="n">obsnme</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="n">are_duplicates</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">unique_obsnames</span><span class="p">)</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">are_duplicates</span><span class="p">):</span>
        <span class="c1">#duplicated_obsnames = set(stacked.loc[are_duplicates.values, &#39;obsnme&#39;])</span>
        <span class="n">steady_obs</span> <span class="o">=</span> <span class="n">stacked</span><span class="o">.</span><span class="n">per</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">perioddata</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">perioddata</span><span class="o">.</span><span class="n">steady</span><span class="p">,</span> <span class="s1">&#39;per&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">drop</span> <span class="o">=</span> <span class="n">are_duplicates</span> <span class="o">&amp;</span> <span class="n">steady_obs</span>
        <span class="n">stacked</span> <span class="o">=</span> <span class="n">stacked</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">drop</span><span class="p">]</span>
        <span class="n">unique_obsnames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unique_obsnames</span><span class="p">)[</span><span class="o">~</span><span class="n">drop</span><span class="p">]</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">unique_obsnames</span><span class="p">)</span><span class="o">.</span><span class="n">duplicated</span><span class="p">())</span>

    <span class="n">stacked</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">stacked</span><span class="p">[</span><span class="s1">&#39;obsnme&#39;</span><span class="p">]</span>
    <span class="n">sort_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;obsprefix&#39;</span><span class="p">,</span> <span class="s1">&#39;per&#39;</span><span class="p">,</span> <span class="s1">&#39;layer&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">stacked</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="n">stacked</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">sort_cols</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">stacked</span>
    <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="get_modflow_mass_balance"><a class="viewcode-back" href="../../api/mfobs.modflow.html#mfobs.modflow.get_modflow_mass_balance">[docs]</a><span class="k">def</span> <span class="nf">get_modflow_mass_balance</span><span class="p">(</span><span class="n">modroot</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">write_ins</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    read in the percent discrepancy for inset and parent models</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    modroot: root name of the model scenario</span>
<span class="sd">    outfile: filepath for output</span>
<span class="sd">    write_ins: bool. whether or not to write instruction file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;reading in the mass balance files&#39;</span><span class="p">)</span>
    <span class="c1"># make a list with which to concatenate results</span>
    <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># read in both inset and parent list files</span>
    <span class="k">for</span> <span class="n">cmod</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;inset&#39;</span><span class="p">,</span> <span class="s1">&#39;parent&#39;</span><span class="p">]:</span>
        <span class="c1"># read in the list files</span>
        <span class="n">mfl6</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">Mf6ListBudget</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}{1}</span><span class="s2">_</span><span class="si">{2}</span><span class="s2">.list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rundir</span><span class="p">,</span> <span class="n">modroot</span><span class="p">,</span> <span class="n">cmod</span><span class="p">))</span>
        <span class="c1"># get all the budget information</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mfl6</span><span class="o">.</span><span class="n">get_dataframes</span><span class="p">(</span><span class="n">start_datetime</span><span class="o">=</span><span class="s2">&quot;1-1-2012&quot;</span><span class="p">)</span>
        <span class="c1"># construct the obsname with the date etc.</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;obsnme&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">_discrep_</span><span class="si">{1:d}{2:02d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cmod</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">month</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        <span class="c1"># append on the max absolute percent discrepancy</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;obsnme&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_discrep_max&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cmod</span><span class="p">),</span>
                        <span class="s1">&#39;PERCENT_DISCREPANCY&#39;</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">PERCENT_DISCREPANCY</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()},</span>
                       <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;obsnme&#39;</span><span class="p">,</span> <span class="s1">&#39;PERCENT_DISCREPANCY&#39;</span><span class="p">]])</span>
    <span class="n">outdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span>
    <span class="n">outdf</span><span class="p">[</span><span class="s1">&#39;group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;percent_discrep&#39;</span>
    <span class="n">outdf</span><span class="p">[</span><span class="s1">&#39;obsval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">outdf</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">write_ins</span><span class="p">:</span>
        <span class="n">write_insfile</span><span class="p">(</span><span class="n">outdf</span><span class="p">,</span> <span class="n">outfile</span> <span class="o">+</span> <span class="s1">&#39;.ins&#39;</span><span class="p">,</span> <span class="n">obsnme_column</span><span class="o">=</span><span class="s1">&#39;obsnme&#39;</span><span class="p">,</span>
                      <span class="n">simulated_obsval_column</span><span class="o">=</span><span class="s1">&#39;PERCENT_DISCREPANCY&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_modelgrid_transform"><a class="viewcode-back" href="../../api/mfobs.modflow.html#mfobs.modflow.get_modelgrid_transform">[docs]</a><span class="k">def</span> <span class="nf">get_modelgrid_transform</span><span class="p">(</span><span class="n">grid_json_file</span><span class="p">,</span> <span class="n">shift_to_cell_centers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create an affine.Affine that describes the model grid</span>
<span class="sd">    from a json file. The affine package comes with rasterio</span>
<span class="sd">    as a dependency or can be installed separately.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid_json_file : str</span>
<span class="sd">        Model grid json file produced by modflow-setup</span>
<span class="sd">    shift_to_cell_centers : bool</span>
<span class="sd">        By default, transform reflects the upper left corner of</span>
<span class="sd">        the first cell in the model, and any conversions of x, y</span>
<span class="sd">        coordinates to pixels will be relative to upper left corners.</span>
<span class="sd">        If shift_to_cell_centers=True, x,y points will be referenced</span>
<span class="sd">        to the nearest cell centers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">grid_json_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">cfg</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="s1">&#39;delr&#39;</span><span class="p">,</span> <span class="s1">&#39;delc&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">cfg</span><span class="p">[</span><span class="n">dx</span><span class="p">]):</span>
            <span class="n">cfg</span><span class="p">[</span><span class="n">dx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="n">dx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">xul</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="s1">&#39;xul&#39;</span><span class="p">]</span>
    <span class="n">yul</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="s1">&#39;yul&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">shift_to_cell_centers</span><span class="p">:</span>
        <span class="n">xul</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cfg</span><span class="p">[</span><span class="s1">&#39;delr&#39;</span><span class="p">]</span>
        <span class="n">yul</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cfg</span><span class="p">[</span><span class="s1">&#39;delc&#39;</span><span class="p">]</span>

    <span class="n">transform</span> <span class="o">=</span> <span class="n">Affine</span><span class="p">(</span><span class="n">cfg</span><span class="p">[</span><span class="s1">&#39;delr&#39;</span><span class="p">],</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">xul</span><span class="p">,</span>
                       <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="n">cfg</span><span class="p">[</span><span class="s1">&#39;delr&#39;</span><span class="p">],</span> <span class="n">yul</span><span class="p">)</span> <span class="o">*</span> \
                <span class="n">Affine</span><span class="o">.</span><span class="n">rotation</span><span class="p">(</span><span class="n">cfg</span><span class="p">[</span><span class="s1">&#39;angrot&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">transform</span></div>


<div class="viewcode-block" id="read_mf6_lake_obs"><a class="viewcode-back" href="../../api/mfobs.modflow.html#mfobs.modflow.read_mf6_lake_obs">[docs]</a><span class="k">def</span> <span class="nf">read_mf6_lake_obs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">perioddata</span><span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="s1">&#39;2012-01-01&#39;</span><span class="p">,</span>
                      <span class="n">keep_only_last_timestep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="c1"># convert modflow time to actual elapsed time</span>
    <span class="c1"># (by subtracting off the day for the initial steady-state period)</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># get stress period information for each timestep recorded</span>
    <span class="n">kstp</span><span class="p">,</span> <span class="n">kper</span> <span class="o">=</span> <span class="n">get_kstp_kper</span><span class="p">(</span><span class="n">perioddata</span><span class="o">.</span><span class="n">nstp</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;kstp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kstp</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;kper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kper</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">kstp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">keep_only_last_timestep</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;kper&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">last</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">start_ts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">start_date</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">start_ts</span>
    <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">datetime</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_transmissivities"><a class="viewcode-back" href="../../api/mfobs.modflow.html#mfobs.modflow.get_transmissivities">[docs]</a><span class="k">def</span> <span class="nf">get_transmissivities</span><span class="p">(</span><span class="n">heads</span><span class="p">,</span> <span class="n">hk</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">botm</span><span class="p">,</span>
                         <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">modelgrid_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">screen_top</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">screen_botm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nodata</span><span class="o">=-</span><span class="mi">999</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes transmissivity in each model layer at specified locations and</span>
<span class="sd">    open intervals. A saturated thickness is determined for each row, column</span>
<span class="sd">    or x, y location supplied, based on the open interval (sctop, screen_botm),</span>
<span class="sd">    if supplied, otherwise the layer tops and bottoms and the water table</span>
<span class="sd">    are used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    heads : 2D array OR 3D array</span>
<span class="sd">        numpy array of shape nlay by n locations (2D) OR complete heads array</span>
<span class="sd">        of the model for one time (3D)</span>
<span class="sd">    hk : 3D numpy array</span>
<span class="sd">        horizontal hydraulic conductivity values.</span>
<span class="sd">    top : 2D numpy array</span>
<span class="sd">        model top elevations.</span>
<span class="sd">    botm : 3D numpy array</span>
<span class="sd">        layer botm elevations.</span>
<span class="sd">    r : 1D array-like of ints, of length n locations</span>
<span class="sd">        row indices (optional; alternately specify x, y)</span>
<span class="sd">    c : 1D array-like of ints, of length n locations</span>
<span class="sd">        column indices (optional; alternately specify x, y)</span>
<span class="sd">    x : 1D array-like of floats, of length n locations</span>
<span class="sd">        x locations in real world coordinates (optional).</span>
<span class="sd">        If x and y are specified, a modelgrid_transform must also be provided.</span>
<span class="sd">    y : 1D array-like of floats, of length n locations</span>
<span class="sd">        y locations in real world coordinates (optional)</span>
<span class="sd">        If x and y are specified, a modelgrid_transform must also be provided.</span>
<span class="sd">    modelgrid_transform : affine.Affine instance, optional</span>
<span class="sd">        An `affine.Affine &lt;https://github.com/sgillies/affine&gt;`_ object describing the orientation</span>
<span class="sd">        of the model grid. Only required for getting i, j if x and y are specified.</span>
<span class="sd">        Modflow-setup :class:`~mfsetup.grid.MFsetupGrid` have this attached</span>
<span class="sd">        via the :meth:`~mfsetup.grid.MFsetupGrid.transform` property. Example::</span>

<span class="sd">            modelgrid_transform=affine.Affine(1000.0, 0.0, 500955,</span>
<span class="sd">                                              0.0, -1000.0, 1205285)</span>

<span class="sd">        for a uniform spacing of 1000 and upper left corner of 500955, 1205285</span>
<span class="sd">        with a rotation of 45 degrees, counter-clockwise about the upper left corner::</span>

<span class="sd">            modelgrid_transform=affine.Affine(1000.0, 0.0, 500955,</span>
<span class="sd">                                              0.0, -1000.0, 1205285).rotation(45.)</span>

<span class="sd">        An ``affine.Affine`` instance can also be created from a</span>
<span class="sd">        `Modflow-setup &lt;https://github.com/aleaf/modflow-setup&gt;`_</span>
<span class="sd">        grid JSON file via the :func:`~mfobs.modflow.get_modelgrid_transform` function.</span>

<span class="sd">    screen_top : 1D array-like of floats, of length n locations</span>
<span class="sd">        open interval tops (optional; default is model top)</span>
<span class="sd">    screen_botm : 1D array-like of floats, of length n locations</span>
<span class="sd">        open interval bottoms (optional; default is model bottom)</span>
<span class="sd">    nodata : numeric</span>
<span class="sd">        optional; locations where heads=nodata will be assigned T=0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T : 2D array of same shape as heads (nlay x n locations)</span>
<span class="sd">        Transmissivities in each layer at each location</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># get row, col for observation locations</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">get_ij</span><span class="p">(</span><span class="n">modelgrid_transform</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must specify row, column or x, y locations.&#39;</span><span class="p">)</span>

    <span class="c1"># get k-values and botms at those locations</span>
    <span class="c1"># (make nlayer x n sites arrays)</span>
    <span class="n">hk2d</span> <span class="o">=</span> <span class="n">hk</span><span class="p">[:,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
    <span class="n">botm2d</span> <span class="o">=</span> <span class="n">botm</span><span class="p">[:,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heads</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">heads</span> <span class="o">=</span> <span class="n">heads</span><span class="p">[:,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>

    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Shape of heads array must be nlay x nhyd&#39;</span>
    <span class="k">assert</span> <span class="n">heads</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">botm2d</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">msg</span>

    <span class="c1"># set open interval tops/bottoms to model top/bottom if None</span>
    <span class="k">if</span> <span class="n">screen_top</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">screen_top</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">screen_botm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">screen_botm</span> <span class="o">=</span> <span class="n">botm</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>

    <span class="c1"># make an nlayers x n sites array of layer tops</span>
    <span class="n">tops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">botm2d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">tops</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
    <span class="n">tops</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">botm2d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># expand top and bottom arrays to be same shape as botm, thickness, etc.</span>
    <span class="c1"># (so we have an open interval value for each layer)</span>
    <span class="n">sctoparr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">botm2d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">sctoparr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">screen_top</span>
    <span class="n">scbotarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">botm2d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">scbotarr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">screen_botm</span>

    <span class="c1"># start with layer tops</span>
    <span class="c1"># set tops above heads to heads</span>
    <span class="c1"># set tops above screen top to screen top</span>
    <span class="c1"># (we only care about the saturated open interval)</span>
    <span class="n">openinvtop</span> <span class="o">=</span> <span class="n">tops</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">openinvtop</span><span class="p">[</span><span class="n">openinvtop</span> <span class="o">&gt;</span> <span class="n">heads</span><span class="p">]</span> <span class="o">=</span> <span class="n">heads</span><span class="p">[</span><span class="n">openinvtop</span> <span class="o">&gt;</span> <span class="n">heads</span><span class="p">]</span>
    <span class="n">openinvtop</span><span class="p">[</span><span class="n">openinvtop</span> <span class="o">&gt;</span> <span class="n">sctoparr</span><span class="p">]</span> <span class="o">=</span> <span class="n">sctoparr</span><span class="p">[</span><span class="n">openinvtop</span> <span class="o">&gt;</span> <span class="n">screen_top</span><span class="p">]</span>

    <span class="c1"># start with layer bottoms</span>
    <span class="c1"># set bottoms below screened interval to screened interval bottom</span>
    <span class="c1"># set screen bottoms below bottoms to layer bottoms</span>
    <span class="n">openinvbotm</span> <span class="o">=</span> <span class="n">botm2d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">openinvbotm</span><span class="p">[</span><span class="n">openinvbotm</span> <span class="o">&lt;</span> <span class="n">scbotarr</span><span class="p">]</span> <span class="o">=</span> <span class="n">scbotarr</span><span class="p">[</span><span class="n">openinvbotm</span> <span class="o">&lt;</span> <span class="n">screen_botm</span><span class="p">]</span>
    <span class="n">openinvbotm</span><span class="p">[</span><span class="n">scbotarr</span> <span class="o">&lt;</span> <span class="n">botm2d</span><span class="p">]</span> <span class="o">=</span> <span class="n">botm2d</span><span class="p">[</span><span class="n">scbotarr</span> <span class="o">&lt;</span> <span class="n">botm2d</span><span class="p">]</span>

    <span class="c1"># compute thickness of open interval in each layer</span>
    <span class="n">thick</span> <span class="o">=</span> <span class="n">openinvtop</span> <span class="o">-</span> <span class="n">openinvbotm</span>

    <span class="c1"># assign open intervals above or below model to closest cell in column</span>
    <span class="n">not_in_layer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">thick</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">not_in_any_layer</span> <span class="o">=</span> <span class="n">not_in_layer</span> <span class="o">==</span> <span class="n">thick</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">not_in_any_layer</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">closest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">thick</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">thick</span><span class="p">[</span><span class="n">closest</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">thick</span><span class="p">[</span><span class="n">thick</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">thick</span><span class="p">[</span><span class="n">heads</span> <span class="o">==</span> <span class="n">nodata</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># exclude nodata cells</span>
    <span class="n">thick</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">heads</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># exclude cells with no head value (inactive cells)</span>

    <span class="c1"># compute transmissivities</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">thick</span> <span class="o">*</span> <span class="n">hk2d</span>
    <span class="k">return</span> <span class="n">T</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
      <span class="lastupdated">
        Last updated on Nov 17, 2020.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>